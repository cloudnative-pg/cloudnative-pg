/*
This file is part of Cloud Native PostgreSQL.

Copyright (C) 2019-2021 EnterpriseDB Corporation.
*/

package postgres

import (
	"context"
	"fmt"
	"path"

	"github.com/EnterpriseDB/cloud-native-postgresql/internal/management/utils"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
	"k8s.io/apimachinery/pkg/runtime/schema"
	"k8s.io/client-go/dynamic"

	"github.com/EnterpriseDB/cloud-native-postgresql/pkg/fileutils"
	"github.com/EnterpriseDB/cloud-native-postgresql/pkg/management/log"
)

// InstallCustomConfigurationFile install in the PgData the file with
// the PostgreSQL settings which have been generated by the operator.
// Returns a flag telling if the configuration has been changed and an error
// state
func InstallCustomConfigurationFile(pgdata, filename string) (bool, error) {
	if filename == "" || pgdata == "" {
		return false, nil
	}

	contents, err := fileutils.ReadFile(filename)
	if err != nil {
		return false, fmt.Errorf("while reading custom configuration file: %w", err)
	}

	return InstallPgDataFileContent(pgdata, contents, PostgresqlCustomConfigurationFile)
}

// InstallPgHBAFile install in the PgData the file containing
// the host-based access rules which is being managed by the operator
func InstallPgHBAFile(pgdata, filename string) (bool, error) {
	if filename == "" || pgdata == "" {
		return false, nil
	}

	contents, err := fileutils.ReadFile(filename)
	if err != nil {
		return false, fmt.Errorf("while reading hba file: %w", err)
	}

	return InstallPgDataFileContent(
		pgdata,
		contents,
		PostgresqlHBARulesFile)
}

// InstallPgDataFileContent install a file in PgData, returning true/false if
// the file has been changed and an error state
func InstallPgDataFileContent(pgdata, contents, destinationFile string) (bool, error) {
	log.Log.Info(
		"Installing configuration file",
		"pgdata", pgdata,
		"filename", destinationFile,
		"contents", contents)

	targetFile := path.Join(pgdata, destinationFile)
	return fileutils.WriteStringToFile(targetFile, contents)
}

// RefreshConfigurationFilesFromObject receive an unstructured object representing
// a configmap and rewrite the file in the PGDATA. This function will return "true"
// it the configuration has been really changed.
// Important: this won't send a SIGHUP to the server
func (instance *Instance) RefreshConfigurationFilesFromObject(object *unstructured.Unstructured) (bool, error) {
	postgresConfiguration, err := utils.GetPostgreSQLConfiguration(object)
	if err != nil {
		return false, err
	}

	postgresHBA, err := utils.GetPostgreSQLHBA(object)
	if err != nil {
		return false, err
	}

	postgresConfigurationChanged, err := InstallPgDataFileContent(
		instance.PgData,
		postgresConfiguration,
		PostgresqlCustomConfigurationFile)
	if err != nil {
		return postgresConfigurationChanged, fmt.Errorf(
			"installing postgresql configuration: %w",
			err)
	}

	postgresHBAChanged, err := InstallPgDataFileContent(
		instance.PgData,
		postgresHBA,
		PostgresqlHBARulesFile)
	if err != nil {
		return postgresConfigurationChanged || postgresHBAChanged, fmt.Errorf(
			"installing postgresql HBA rules: %w",
			err)
	}

	return postgresConfigurationChanged || postgresHBAChanged, nil
}

// RefreshConfigurationFiles get the latest version of the ConfigMap from the API
// server and then write the configuration in PGDATA
func (instance *Instance) RefreshConfigurationFiles(ctx context.Context, client dynamic.Interface) (bool, error) {
	unstructuredObject, err := client.Resource(schema.GroupVersionResource{
		Group:    "",
		Version:  "v1",
		Resource: "configmaps",
	}).
		Namespace(instance.Namespace).
		Get(ctx, instance.ClusterName, metav1.GetOptions{})
	if err != nil {
		return false, err
	}

	return instance.RefreshConfigurationFilesFromObject(unstructuredObject)
}
