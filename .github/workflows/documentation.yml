name: documentation

on:
  push:
    branches:
      - main
    tags:
      - v*
    paths:
      - 'docs/**'
  workflow_dispatch:

defaults:
  run:
    shell: 'bash -Eeuo pipefail -x {0}'

jobs:

  mkdocs_documentation:
    name: Create mkdocs documentation
    runs-on: ubuntu-20.04
    outputs:
      version: ${{ steps.get-version.outputs.VERSION }}
      maturity: ${{ steps.get-version.outputs.MATURITY }}
    env:
      PROJECT_NAME: "cloud-native-postgresql"
      PDF_TITLE: "Cloud Native PostgreSQL"
    steps:
      -
        name: Checkout code
        uses: actions/checkout@v3
        with:
          # We need the full history to use `git describe`
          fetch-depth: 0
      -
        name: Login to Quay.io Docker Registry
        uses: docker/login-action@v1
        with:
          registry: quay.io/enterprisedb
          username: ${{ secrets.QUAY_USERNAME }}
          password: ${{ secrets.QUAY_TOKEN }}
      -
        name: Get version
        id: get-version
        run: |
          # Detect git version
          git_describe=$(git describe --tags --always --long)
          git_hash=${git_describe##*-g}
          git_remainder=${git_describe%-g*}
          # If the output is not a bare hash extract the tag
          if [ "$git_remainder" != "$git_hash" ]
          then
              git_seq=${git_remainder##*-}
              git_tag=${git_remainder%-*}
          else
              # Otherwise use the commit count since the root
              git_seq=$(git rev-list HEAD --count)
              git_tag=0.0.0
          fi

          # Mangle the tag name to extract the version.
          # Remove an eventual initial 'v' character
          git_tag=${git_tag#v}

          # Set outputs for different maturity levels
          if [ "$git_seq" -eq 0 ]
          then
              VERSION=${git_tag}
              MATURITY=release
          else
              # Otherwise increment the last version component and build it as a pre-release
              VERSION="$(echo "${git_tag}" | awk -F. -vOFS=. '{$NF+=1; print $0}')-dev${git_seq}"
              MATURITY=snapshot
          fi
          echo "::set-output name=VERSION::${VERSION}"
          echo "::set-output name=MATURITY::${MATURITY}"
      -
        name: Add a page to download the documentation in PDF version
        run: |
            cp docs/mkdocs.yml docs/mkdocs.yml.orig
            echo "  - pdf_version.md" >> docs/mkdocs.yml
            {
              cat <<EOF

            # PDF Version

            You can access the [complete documentation in PDF format](../${PROJECT_NAME}.pdf).
            EOF
            } > docs/src/pdf_version.md
      -
        name: Build the documentation with mkdocs
        run: |
            docker run --rm -v "${GITHUB_WORKSPACE}:${GITHUB_WORKSPACE}" \
                -w ${GITHUB_WORKSPACE}/docs \
                quay.io/enterprisedb/cloud-native-docutils:mkdocs \
                mkdocs build -v -d "${GITHUB_WORKSPACE}/docs/dist"
      -
        name: Generate the PDF using pandoc
        run: |
            # Clean the directory, we don't want a link to the PDF in the PDF
            rm -f docs/src/pdf_version.md
            mv docs/mkdocs.yml.orig docs/mkdocs.yml
            docker run --rm -v "${GITHUB_WORKSPACE}:${GITHUB_WORKSPACE}" \
                -w "${GITHUB_WORKSPACE}/docs/dist" \
                -e VERSION="${{ steps.get-version.outputs.VERSION }}" \
                -e PDF_TITLE="${PDF_TITLE}" \
                -e PROJECT_NAME="${PROJECT_NAME}" \
                -e SRCDIR="${GITHUB_WORKSPACE}" \
                --entrypoint= \
                quay.io/enterprisedb/cloud-native-docutils:publisher \
                /tools/build_pdf_docs.sh ${GITHUB_WORKSPACE}
      -
        name: Prepare data for upload
        run: |
          mkdir -p upload/latest upload/manifests
          cat > "upload/latest/.htaccess" <<EOF
          RewriteEngine On
          RewriteCond %{REQUEST_URI} ^(.*)/latest/(/?.*)
          RewriteRule ^ %1/${{ steps.get-version.outputs.VERSION }}/%2 [R=302,L]
          EOF
          cp -R docs/dist upload/${{ steps.get-version.outputs.VERSION }}
          cp -R releases upload/${{ steps.get-version.outputs.VERSION }}/manifests
          cp -R $(ls releases/postgresql-operator-*.yaml | sort -rV | head -n 1) upload/manifests
      -
        name: Upload the documentation via FTP
        working-directory: upload
        run: |
          find . -type f -print0 | \
              docker run -i --rm -v "$(pwd):$(pwd)" -w "$(pwd)" \
              --entrypoint="" \
              curlimages/curl \
                  xargs -t -0 -I{} -n1 \
                  curl --ssl --ftp-create-dirs --retry 999 -s  --tls-max 1.2 \
                  -u ${{ secrets.DOCS_FTP_USERNAME }}:${{ secrets.DOCS_FTP_PASSWORD }} \
                  ftp://${{ secrets.DOCS_FTP_SERVER }}/${PROJECT_NAME}/${{ steps.get-version.outputs.MATURITY }}/{} \
                  --upload-file {}

  trigger-edb-docs:
    name: Trigger EDB Docs
    needs:
      - mkdocs_documentation
    runs-on: ubuntu-20.04
    steps:
      - name: Repository Dispatch
        uses: peter-evans/repository-dispatch@v2
        with:
          token: ${{ secrets.REPO_GHA_PAT }}
          repository: enterprisedb/docs
          event-type: sync-to-docs
          client-payload: |
            {
              "maturity": "${{ needs.mkdocs_documentation.outputs.maturity }}",
              "version": "${{ needs.mkdocs_documentation.outputs.version }}",
              "ref": "${{ github.ref }}",
              "repo": "${{ github.repository }}",
              "sha": "${{ github.sha }}"
            }
