name: continuous-delivery

on:
  push:
  pull_request:
  workflow_dispatch:
    inputs:
      depth:
        description: 'Depth (push, pull_request, main, schedule)'
        required: true
        default: 'main'
      limit:
        description: 'Limit to the specified engines list (local, eks)'
        required: false

env:
  GOLANG_VERSION: "1.14.x"
  GOLANGCI_LINT_VERSION: "v1.33"
  KUBEBUILDER_VERSION: "2.3.1"
  KIND_VERSION: "v0.9.0"

defaults:
  run:
    shell: 'bash -Eeuo pipefail -x {0}'

jobs:

  golangci:
    name: Run linters
    runs-on: ubuntu-20.04
    steps:
      -
        name: Checkout code
        uses: actions/checkout@v2
      -
        name: Run golangci-lint
        uses: golangci/golangci-lint-action@v2.4.0
        with:
          version: ${{ env.GOLANGCI_LINT_VERSION }}
          args: --timeout 4m

  shellcheck:
    name: Run shellcheck linter
    runs-on: ubuntu-20.04
    env:
        SHELLCHECK_OPTS: -a -S style
    steps:
    -
      uses: actions/checkout@v2
    -
      name: Run ShellCheck
      uses: ludeeus/action-shellcheck@master

  tests:
    name: Run unit tests
    runs-on: ubuntu-20.04
    steps:
      -
        name: Checkout code
        uses: actions/checkout@v2
      -
        name: Install Go
        uses: actions/setup-go@v2
        with:
          go-version: ${{ env.GOLANG_VERSION }}
      # Install kubebuilder that is a requirement to run tests
      -
        name: Install Kubebuilder
        run: |
          mkdir -p /tmp/kubebuilder
          curl -sSL https://go.kubebuilder.io/dl/${{ env.KUBEBUILDER_VERSION }}/$(go env GOOS)/$(go env GOARCH) | tar --strip-components=1 -xz -C /tmp/kubebuilder
          sudo mv /tmp/kubebuilder /usr/local/
      -
        name: Run unit tests
        run:
          make test

  buildx:
    name: Build containers
    needs:
      - golangci
      - shellcheck
      - tests
    runs-on: ubuntu-20.04
    outputs:
      image: ${{ steps.image-meta.outputs.image }}
    steps:
      -
        name: Checkout
        uses: actions/checkout@v2
      -
        name: Build meta
        id: build-meta
        run: |
          # By default, set the "testing" target repository on Quay.io
          # (every built container is pushed there)
          images='quay.io/enterprisedb/cloud-native-postgresql-testing'
          tags=''
          labels=''
          # In case we have a tag, add the main target repository
          if [ "${GITHUB_REF#refs/tags/}" != "${GITHUB_REF}" ]
          then
            images="${images},quay.io/enterprisedb/cloud-native-postgresql"
          fi
          # In case of commit on the "main" branch or tag, set the "latest"
          # label to the container image on the target repositories.
          # Otherwise set expiration to 7 days.
          if [ "${GITHUB_REF#refs/heads/}" == main ] || [ "${GITHUB_REF#refs/tags/}" != "${GITHUB_REF}" ]
          then
            tags='latest'
          else
            labels='quay.expires-after=7d'
          fi
          echo "::set-output name=images::${images}"
          echo "::set-output name=tags::${tags}"
          echo "::set-output name=labels::${labels}"
      -
        name: Docker meta
        id: docker-meta
        uses: crazy-max/ghaction-docker-meta@v1
        with:
          images: ${{ steps.build-meta.outputs.images }}
          tag-custom: ${{ steps.build-meta.outputs.tags }}
          tag-semver: |
            {{version}}
      -
        name: Set up QEMU
        uses: docker/setup-qemu-action@v1
      -
        name: Set up Docker Buildx
        id: buildx
        uses: docker/setup-buildx-action@v1
      -
        name: Login to quay.io
        uses: docker/login-action@v1
        with:
          registry: quay.io/enterprisedb
          username: ${{ secrets.QUAY_USERNAME }}
          password: ${{ secrets.QUAY_TOKEN }}
      -
        name: Build and push
        uses: docker/build-push-action@v2
        with:
          # Available architecture on UBI8 are: linux/amd64, linux/arm64, linux/ppc64le
          platforms: linux/amd64
          push: true
          tags: ${{ steps.docker-meta.outputs.tags }}
          labels: ${{ steps.build-meta.outputs.labels }}
      -
        name: Image Meta
        id: image-meta
        env:
          TAGS: ${{ steps.docker-meta.outputs.tags }}
        run: |
          # If there is more than one tag, take the first one
          # TAGS could be separated by newlines or commas
          image=$(sed -n '1{s/,.*//; p}' <<< "$TAGS")
          echo "::set-output name=image::${image}"

  trigger-ocp:
    name: Trigger OCP bundle
    needs:
      - golangci
      - shellcheck
      - tests
    runs-on: ubuntu-20.04
    steps:
      - name: Repository Dispatch
        uses: peter-evans/repository-dispatch@v1
        with:
          token: ${{ secrets.REPO_GHA_PAT }}
          repository: enterprisedb/cloud-native-postgresql-ocp-certified
          event-type: cnp-trigger
          client-payload: '{"upstream_commit": "${{ github.sha }}"}'

  generate-jobs:
    name: Generate jobs for E2E tests
    needs:
      - buildx
    runs-on: ubuntu-20.04
    outputs:
      localMatrix: ${{ steps.generate-jobs.outputs.localMatrix }}
      localEnabled: ${{ steps.generate-jobs.outputs.localEnabled }}
      eksMatrix: ${{ steps.generate-jobs.outputs.eksMatrix }}
      eksEnabled: ${{ steps.generate-jobs.outputs.eksEnabled }}
    steps:
      -
        name: Checkout code
        uses: actions/checkout@v2
      -
        name: Docker meta
        id: docker-meta
        uses: crazy-max/ghaction-docker-meta@v1
        with:
          images: quay.io/enterprisedb/cloud-native-postgresql-testing
          tag-semver: |
            {{version}}
      -
        id: generate-jobs
        name: Generate Jobs
        shell: bash
        run: |
          python .github/e2e-matrix-generator.py \
            -m '${{ github.event.inputs.depth || github.event_name }}' \
            -l '${{ github.event.inputs.limit }}'

  e2e-local:
    name: Run E2E on local executors
    if: needs.generate-jobs.outputs.localEnabled == 'true'
    needs:
      - buildx
      - generate-jobs
    strategy:
      fail-fast: false
      matrix: ${{ fromJSON(needs.generate-jobs.outputs.localMatrix) }}
    runs-on: ubuntu-20.04
    env:
      K8S_VERSION: "${{ matrix.k8s_version }}"
      POSTGRES_IMG: "${{ matrix.postgres_img }}"
      E2E_PRE_ROLLING_UPDATE_IMG: "${{ matrix.postgres_pre_img }}"

      DOCKER_SERVER: quay.io/enterprisedb
      DOCKER_USERNAME: ${{ secrets.QUAY_USERNAME }}
      DOCKER_PASSWORD: ${{ secrets.QUAY_TOKEN }}

      DEBUG: "true"
      BUILD_IMAGE: "false"
      CONTROLLER_IMG: ${{ needs.buildx.outputs.image }}
      E2E_DEFAULT_STORAGE_CLASS: standard
      LOG_DIR: ${{ github.workspace }}/kind-logs/
      DOCKER_REGISTRY_MIRROR: https://mirror.gcr.io
    steps:
      -
        name: Checkout code
        uses: actions/checkout@v2
      -
        name: Install Go
        uses: actions/setup-go@v2
        with:
          go-version: ${{ env.GOLANG_VERSION }}
      -
        name: Run Kind End-to-End tests
        run:
          make e2e-test-kind
      -
        name: Archive Kind logs
        if: failure()
        uses: actions/upload-artifact@v2
        with:
          name: kind-logs-${{ matrix.id }}
          path: kind-logs/
          retention-days: 7
      -
        name: Archive e2e failure contexts
        if: failure()
        uses: actions/upload-artifact@v2
        with:
          name: test-failure-contexts-${{ matrix.id }}
          path: |
            tests/*/out/
          retention-days: 7
          if-no-files-found: ignore

  e2e-eks:
    name: Run E2E on Amazon EKS
    if: needs.generate-jobs.outputs.eksEnabled == 'true'
    needs:
      - buildx
      - generate-jobs
    strategy:
      fail-fast: false
      matrix:
         ${{ fromJSON(needs.generate-jobs.outputs.eksMatrix) }}
    runs-on: ubuntu-20.04
    env:
      K8S_VERSION: "${{ matrix.k8s_version }}"
      POSTGRES_IMG: "${{ matrix.postgres_img }}"
      E2E_PRE_ROLLING_UPDATE_IMG: "${{ matrix.postgres_pre_img }}"

      DOCKER_SERVER: quay.io/enterprisedb
      DOCKER_USERNAME: ${{ secrets.QUAY_USERNAME }}
      DOCKER_PASSWORD: ${{ secrets.QUAY_TOKEN }}

      DEBUG: "true"
      BUILD_IMAGE: "false"
      CONTROLLER_IMG: ${{ needs.buildx.outputs.image }}
      E2E_DEFAULT_STORAGE_CLASS: gp2

      AWS_REGION: eu-central-1
    steps:
      -
        name: Set cluster name
        run: |
          echo "CLUSTER_NAME=cnp-test-${{ github.run_number }}-$( echo ${{ matrix.id }} | tr -d '_.-' )" >> $GITHUB_ENV
      -
        name: Checkout code
        uses: actions/checkout@v2
      -
        name: Install Go
        uses: actions/setup-go@v2
        with:
          go-version: ${{ env.GOLANG_VERSION }}
      -
        name:  Install ginkgo
        run: |
          go install -mod=readonly github.com/onsi/ginkgo/ginkgo
      -
        name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v1
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}
      -
        name: Install eksctl
        run: |
          mkdir -p "$HOME/.local/bin"
          curl -sL "https://github.com/weaveworks/eksctl/releases/latest/download/eksctl_$(uname -s)_amd64.tar.gz" \
            | tar xz -C $HOME/.local/bin
          echo "$HOME/.local/bin" >> $GITHUB_PATH
      -
        name: Configure EKS setup
        run: |
          envsubst < hack/e2e/eks-cluster.yaml.template > hack/e2e/eks-cluster.yaml
      -
        name: Setup EKS
        run: |
          eksctl create cluster -f hack/e2e/eks-cluster.yaml
      -
        name: Setup log archiving via fluentd and insights
        run: |
          curl https://raw.githubusercontent.com/aws-samples/amazon-cloudwatch-container-insights/latest/k8s-deployment-manifest-templates/deployment-mode/daemonset/container-insights-monitoring/quickstart/cwagent-fluentd-quickstart.yaml \
            | sed "s/{{cluster_name}}/${{ env.CLUSTER_NAME }}/;s/{{region_name}}/${{ env.AWS_REGION }}/" \
            | kubectl apply -f -
      -
        name: Run E2E tests
        run: hack/e2e/run-e2e.sh
      -
        name: Archive e2e failure contexts
        if: failure()
        uses: actions/upload-artifact@v2
        with:
          name: test-failure-contexts-${{ matrix.id }}
          path: |
            tests/*/out/
          retention-days: 7
          if-no-files-found: ignore
      -
        name: Clean up
        if: always()
        run: |
          while true; do
              output=$( eksctl delete cluster -n ${{ env.CLUSTER_NAME }} -r "${{ env.AWS_REGION }}" --wait 2>&1 )
              status=$?
              if [[ $status == 0 ]]; then
                  echo "EKS cluster deleted"
                  break
              fi
              if ( grep "ResourceNotFoundException: No cluster found for name: ${{ env.CLUSTER_NAME }}" <<< "$output" ); then
                  echo "EKS cluster doesn't exist, nothing to remove"
                  break
              fi
              echo "Failed deleting cluster ${{ env.CLUSTER_NAME }}, retrying"
              sleep 5
          done
